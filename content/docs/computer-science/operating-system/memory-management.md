---
title: 存储器管理
weight: 500
math: false
---

- **功能**
    - 存储器分配：解决多道程序或多进程共享内存的问题。
    - 地址转换或重定位：地址变换的方法和相关硬件。
    - 存储器保护：访问权限控制。
        - 防止越界
        - 正确地存取：对存储空间的操作进行检查。
    - 存储器扩充：允许虚拟存储器的使用。
    - 存储器共享：允许进程共享内存中的内容。
- **分配机制**
    - **单用户单道程序**
        - 把单一一块连续内存分配给唯一的运行程序，运行结束后释放。
        - 存储保护容易实现，容易判断是否越界。
    - **分区管理**
        - **固定式分区分配**
            - 把内存分为若干个不同大小的分区，不同的程序按照大小装入不同分区。
            - 使用的数据结构：分区说明表，包含每个分区的起始位置、分区大小、占用标志（使用的进程）。
            - 多进程队列分配：每个分区一个队列，程序按照大小进入不同队列，按顺序使用。
                - 单个队列容易拥挤。
            - 单进程队列分配：所有进程处于同一队列，有分区空闲时在队列中搜索一个进程并分配。
            - 实现简单，但是每个分区都会造成空间浪费。
            - 使用静态重定位，进程使用物理地址，使用上下界寄存器实现保护。
        - **可变式分区分配**
            - 根据作业的大小分配分区，分区大小恰好等于作业的大小。
            - 分区的大小、数量都是不确定的。
            - 使用的数据结构：分区说明表或空闲区链表。
                - 分区说明表：包含两个表，分别表示已分配和未分配内存，内部结构与固定式分区结构相同。
                - 空闲区链表：只记录空闲内存，内存块用指针连接形成双向链表，块首尾都包含块的元信息。
            - 分配算法：
                - 首次适应：按顺序查找内存块，分配第一个满足需求的内存块，剩余空间保留。
                - 最佳适应：查找满足需求的最小内存块并分配。缺点：
                    - 需要扫描所有空闲块，可以通过按大小排序空闲块改进。
                    - 容易把内存划分很小，造成碎片化。
                - 最坏适应：查找最大内存块并分配。
                    - 优点：避免内存碎片。
                    - 缺点：大进程的需求可能无法满足。需要扫描所有空闲块。
            - 回收内存块后，需要尝试把此内存块与相邻的空闲块合并。
            - 使用动态重定位，进程使用逻辑地址，使用基址和限长寄存器实现保护。
        - **优缺点**
            - 优点：
                - 允许多道程序共享内存。
                - 实现简单。
                - 保护手段简单。
            - 缺点：
                - 容易造成内存碎片。
                - 没有扩充内存，地址空间受限于实际内存大小。
    - 
